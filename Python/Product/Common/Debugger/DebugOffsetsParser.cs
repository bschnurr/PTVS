// Shared parser for CPython 3.14+ _Py_DebugOffsets (PEP 768)
// Strict + extended scan followed by optional relaxed passes; flexible fallback gated by env var.
using System;
using System.Diagnostics;
using System.Text;

namespace Microsoft.PythonTools.Debugging.Shared {
    public struct ParsedDebugOffsets {
        public uint Version; public byte Flags; public ulong EvalBreaker; public ulong RemoteSupport; public ulong PendingCall; public ulong ScriptPath; public ulong ScriptPathSize; public bool FreeThreaded; public bool RemoteDebugDisabled; public ulong RuntimeState; public ulong InterpretersHead; public ulong InterpretersMain; public ulong ThreadsHead; public ulong ThreadsMain; public ulong ThreadNext; public bool HasInterpreterWalk => ThreadNext != 0 && (ThreadsHead != 0 || ThreadsMain != 0) && (InterpretersMain != 0 || InterpretersHead != 0); public bool NonCanonicalSize; public bool ReorderedTuple; }

    public static class DebugOffsetsParser {
        public const string Cookie="xdebugpy"; public const uint MinSupportedVersion=0x030E0000; private const byte FLAG_FREE_THREADED=0x01; private const byte FLAG_REMOTE_DEBUG_DISABLED=0x02; private const ulong EXPECTED_SCRIPT_PATH_SIZE=512; private const ulong STRICT_MAX_SMALL_OFFSET=0x10000; private const ulong RELAXED_MAX_REMOTE_SUPPORT=0x1000000; private const int RELAXED_SECOND_PASS_SCORE_FLOOR=10; private const ulong FLEX_MIN_SCRIPT_PATH_SIZE=512; private const ulong FLEX_MAX_SCRIPT_PATH_SIZE=0x100000;

        public static bool TryParse(byte[] data, ulong baseAddress, int pointerSize, out ParsedDebugOffsets result, out string failure) {
            result=default; failure=string.Empty; if(data==null||data.Length<64){ failure="buffer too small"; return false;} if(pointerSize!=4&&pointerSize!=8){ failure="invalid pointer size"; return false;} if(!HasCookie(data)){ failure="cookie mismatch"; return false; }
            uint ver=(uint)RQ(data,1); if((ver & 0xFFFF0000) < MinSupportedVersion){ failure=$"unsupported version 0x{ver:X8}"; return false; } byte rawFlags=(byte)(RQ(data,2)&0xFF); bool dump=true; if(dump) Debug.WriteLine($"[PTVS][OffsetsParser] ver=0x{ver:X8} rawFlags=0x{rawFlags:X2}");
            if(StrictPass(data,dump,out var strict,out _)){ result=BuildResult(ver,rawFlags,strict,false,false); PopulateInterpreterOffsets(data,strict.index+5,ref result,dump); return true; }
            if(ExtendedScan(data,dump,out var ext,out _)){ result=BuildResult(ver,rawFlags,ext,false,false); PopulateInterpreterOffsets(data,ext.index+5,ref result,dump); return true; }
            if(RelaxedRemoteSupportScan(data,dump,out var rel)){ if(dump) Debug.WriteLine($"[PTVS][OffsetsParser.Relaxed] Accepted relaxed layout blockIndex={rel.index} eb=0x{rel.eb:X} rs=0x{rel.rs:X} pc=0x{rel.pc:X} sp=0x{rel.sp:X} size={rel.sz}"); result=BuildResult(ver,rawFlags,rel,false,false); PopulateInterpreterOffsets(data,rel.index+5,ref result,dump); return true; }
            if(EnvVarTrue("PTVS_SAFE_ATTACH_FLEX_FALLBACK") && FlexibleFallbackScan(data,dump,out var flex)){ if(dump) Debug.WriteLine($"[PTVS][OffsetsParser.Flexible] Accepted fallback layout winIndex={flex.index} eb=0x{flex.eb:X} rs=0x{flex.rs:X} pc=0x{flex.pc:X} sp=0x{flex.sp:X} size=0x{flex.sz:X}"); result=BuildResult(ver,rawFlags,flex, flex.sz!=EXPECTED_SCRIPT_PATH_SIZE,true); PopulateInterpreterOffsets(data,flex.index+5,ref result,dump); return true; }
            failure="no valid layout"; return false; }

        private struct Block { public int index; public ulong eb,rs,pc,sp,sz; }
        private static bool StrictPass(byte[] data,bool dump,out Block block,out string reason){ block=default; reason="not found"; int qwords=data.Length/8; for(int i=2;i+4<qwords;i++){ if(i==1) continue; ulong a=RQ(data,i),b=RQ(data,i+1),c=RQ(data,i+2),d=RQ(data,i+3),e=RQ(data,i+4); if(e!=EXPECTED_SCRIPT_PATH_SIZE) continue; if(!(a>0&&a<STRICT_MAX_SMALL_OFFSET)) continue; if(!(b>0&&b<STRICT_MAX_SMALL_OFFSET)) continue; if(!(c<STRICT_MAX_SMALL_OFFSET)) continue; if(!(d>0&&d<e)) continue; if((c%4)!=0) continue; if(!(d>=c+4)) continue; block=new Block{index=i,eb=a,rs=b,pc=c,sp=d,sz=e}; if(dump) Debug.WriteLine($"[PTVS][OffsetsParser.Strict] blockIndex={i} byteOff=0x{(i*8):X} eb=0x{a:X} rs=0x{b:X} pc=0x{c:X} sp=0x{d:X} size={e}"); return true;} return false; }
        private static bool ExtendedScan(byte[] data,bool dump,out Block block,out string reason){ block=default; reason="not found"; int qwords=data.Length/8; Block best=default; int bestScore=-1; for(int i=2;i+4<qwords;i++){ if(i==1) continue; ulong a=RQ(data,i),b=RQ(data,i+1),c=RQ(data,i+2),d=RQ(data,i+3),e=RQ(data,i+4); if(e!=EXPECTED_SCRIPT_PATH_SIZE) continue; if(!(a>0&&a<STRICT_MAX_SMALL_OFFSET)) continue; if(!(b>0&&b<STRICT_MAX_SMALL_OFFSET)) continue; if(!(c<STRICT_MAX_SMALL_OFFSET)) continue; if(!(d>0&&d<e)) continue; if((c%4)!=0) continue; if(!(d>=c+4)) continue; int score=0; if(c==0||c==4) score+=30; if(d==c+4) score+=30; score+=(int)(STRICT_MAX_SMALL_OFFSET-Math.Min(a,STRICT_MAX_SMALL_OFFSET))/256; score+=(int)(STRICT_MAX_SMALL_OFFSET-Math.Min(b,STRICT_MAX_SMALL_OFFSET))/256; score+=(int)(0x0200-Math.Min(d,0x200UL)); if(score>bestScore){bestScore=score; best=new Block{index=i,eb=a,rs=b,pc=c,sp=d,sz=e};}} if(bestScore>=0){ block=best; if(dump) Debug.WriteLine($"[PTVS][OffsetsParser.Extended] blockIndex={best.index} byteOff=0x{(best.index*8):X} eb=0x{best.eb:X} rs=0x{best.rs:X} pc=0x{best.pc:X} sp=0x{best.sp:X} size={best.sz}"); return true;} return false; }
        private static bool RelaxedRemoteSupportScan(byte[] data,bool dump,out Block block){ block=default; int qwords=data.Length/8; Block best=default; int bestScore=-1; for(int i=2;i+4<qwords;i++){ if(i==1) continue; ulong a=RQ(data,i),b=RQ(data,i+1),c=RQ(data,i+2),d=RQ(data,i+3),e=RQ(data,i+4); if(e!=EXPECTED_SCRIPT_PATH_SIZE) continue; if(!(a>0&&a<STRICT_MAX_SMALL_OFFSET)) continue; if(!(b>0&&b<RELAXED_MAX_REMOTE_SUPPORT)) continue; if(!(c<RELAXED_MAX_REMOTE_SUPPORT)) continue; if((c%4)!=0) continue; if(!(d>0&&d<e)) continue; if(!(d>=c+4)) continue; int score=0; if(c==0||c==4) score+=25; if(d==c+4) score+=25; if(b<0x200000) score+=30; score+=(int)(0x200-Math.Min(d,0x200UL)); if(score>bestScore){bestScore=score; best=new Block{index=i,eb=a,rs=b,pc=c,sp=d,sz=e};}} if(bestScore>=RELAXED_SECOND_PASS_SCORE_FLOOR){ block=best; return true;} if(dump) Debug.WriteLine("[PTVS][OffsetsParser.Relaxed] No candidate met relaxed criteria"); return false; }
        private static bool FlexibleFallbackScan(byte[] data,bool dump,out Block block){ block=default; int qwords=data.Length/8; Block best=default; int bestScore=-1; int maxWindows=Math.Min(qwords-5,256); for(int i=0;i<=maxWindows;i++){ ulong v0=RQ(data,i),v1=RQ(data,i+1),v2=RQ(data,i+2),v3=RQ(data,i+3),v4=RQ(data,i+4); ulong[] vals={v0,v1,v2,v3,v4}; bool anySize=false; for(int s=0;s<5;s++){ if(vals[s]>=FLEX_MIN_SCRIPT_PATH_SIZE && vals[s]<=FLEX_MAX_SCRIPT_PATH_SIZE){ anySize=true; break; }} if(!anySize) continue; for(int sIdx=0;sIdx<5;sIdx++){ ulong size=vals[sIdx]; if(size<FLEX_MIN_SCRIPT_PATH_SIZE||size>FLEX_MAX_SCRIPT_PATH_SIZE) continue; for(int spIdx=0; spIdx<5; spIdx++){ if(spIdx==sIdx) continue; ulong sp=vals[spIdx]; if(!(sp>0&&sp<size)) continue; for(int pcIdx=0; pcIdx<5; pcIdx++){ if(pcIdx==sIdx||pcIdx==spIdx) continue; ulong pc=vals[pcIdx]; if(pc>=sp||(pc%4)!=0) continue; if(sp-pc<4||sp-pc>0x200) continue; for(int r1=0;r1<5;r1++){ if(r1==sIdx||r1==spIdx||r1==pcIdx) continue; int r2=-1; for(int t=0;t<5;t++){ if(t!=sIdx && t!=spIdx && t!=pcIdx && t!=r1){ r2=t; break; }} ulong c1=vals[r1], c2=vals[r2]; EvalFlex(i,c1,c2,pc,sp,size,dump,ref bestScore,ref best); EvalFlex(i,c2,c1,pc,sp,size,dump,ref bestScore,ref best); }}}}} if(bestScore>=0){ block=best; return true;} return false; }
        private static void EvalFlex(int win,ulong eb,ulong rs,ulong pc,ulong sp,ulong size,bool dump,ref int bestScore,ref Block best){ if(eb==0||rs==0) return; if(eb>=0x1000000UL) return; if(rs>=0x10000000UL) return; int score=0; if(pc==0||pc==4) score+=20; if(sp==pc+4) score+=25; if(size==EXPECTED_SCRIPT_PATH_SIZE) score+=40; else score+= (int)Math.Max(0,30-(int)(Math.Abs((long)size-(long)EXPECTED_SCRIPT_PATH_SIZE)/32)); if(eb<0x4000) score+=10; if(rs<0x40000) score+=10; if(score>bestScore){ bestScore=score; best=new Block{index=win,eb=eb,rs=rs,pc=pc,sp=sp,sz=size}; if(dump) Debug.WriteLine($"[PTVS][OffsetsParser.FlexEval] win={win} eb=0x{eb:X} rs=0x{rs:X} pc=0x{pc:X} sp=0x{sp:X} size=0x{size:X} score={score}"); }}
        private static ParsedDebugOffsets BuildResult(uint ver,byte rawFlags,Block b,bool nonCanonical,bool reordered)=> new ParsedDebugOffsets{ Version=ver,Flags=rawFlags,EvalBreaker=b.eb,RemoteSupport=b.rs,PendingCall=b.pc,ScriptPath=b.sp,ScriptPathSize=b.sz,FreeThreaded=(rawFlags & FLAG_FREE_THREADED)!=0,RemoteDebugDisabled=(rawFlags & FLAG_REMOTE_DEBUG_DISABLED)!=0,NonCanonicalSize=nonCanonical,ReorderedTuple=reordered};
        private static void PopulateInterpreterOffsets(byte[] data,int startQword,ref ParsedDebugOffsets r,bool dump){ int qwords=data.Length/8; if(startQword+6>qwords){ if(dump) Debug.WriteLine($"[PTVS][OffsetsParser.Interpreter] Not enough qwords for walk metadata (need 6, have {qwords-startQword}) startIndex={startQword}"); return;} ulong rt=RQ(data,startQword+0), ih=RQ(data,startQword+1), im=RQ(data,startQword+2), th=RQ(data,startQword+3), tm=RQ(data,startQword+4), tn=RQ(data,startQword+5); bool small(ulong v)=> v<0x20000; bool condRt=(rt==0||small(rt)); bool condIh=small(ih); bool condIm=small(im); bool condThTm=small(th|tm); bool condTn=small(tn)&&tn!=0; bool accept=condRt&&condIh&&condIm&&condThTm&&condTn; if(accept){ r.RuntimeState=rt; r.InterpretersHead=ih; r.InterpretersMain=im; r.ThreadsHead=th; r.ThreadsMain=tm; r.ThreadNext=tn; if(dump) Debug.WriteLine($"[PTVS][OffsetsParser.Interpreter] rt=0x{rt:X} ih=0x{ih:X} im=0x{im:X} th=0x{th:X} tm=0x{tm:X} tn=0x{tn:X}"); } else if(dump){ Debug.WriteLine($"[PTVS][OffsetsParser.Interpreter] Rejected candidate walk metadata rt=0x{rt:X} ih=0x{ih:X} im=0x{im:X} th=0x{th:X} tm=0x{tm:X} tn=0x{tn:X} condRt={condRt} condIh={condIh} condIm={condIm} condThTm={condThTm} condTn={condTn}"); }}
        private static bool HasCookie(byte[] data){ if(data.Length<Cookie.Length) return false; for(int i=0;i<Cookie.Length;i++) if(data[i]!=(byte)Cookie[i]) return false; return true; }
        private static ulong RQ(byte[] data,int index){ int off=index*8; return (off+8<=data.Length)? BitConverter.ToUInt64(data,off):0UL; }
        private static bool EnvVarTrue(string name)=> string.Equals(Environment.GetEnvironmentVariable(name),"1",StringComparison.Ordinal);
        public static string Hex(byte[] data,int count=64){ if(data==null) return string.Empty; int len=Math.Min(count,data.Length); var sb=new StringBuilder(len*3); for(int i=0;i<len;i++){ if(i>0) sb.Append(' '); sb.Append(data[i].ToString("X2")); } return sb.ToString(); }
    }
}
